---
layout: post
title:  "数据库系统概念学习笔记(三)"
date:   2019-1-24 19:45
description: (第六版)第三章 -- from "Database System Concepts" Avi Silberschatz, Henry F. Korth, S. Sudarshan
comments: true
tag:
- sql
- 数据库系统概念
---

#笔记
> 数据定义语言(DDL): 定义关系模式、删除关系和修改关系模式。
> 数据操纵语言(DML): 查询，以及插入、删除、修改数据库中的元组。

#书后习题
##
```sql
-- # 3.1
-- a
SELECT course_id FROM course WHERE credits=3 AND dept_name='Comp. Sci.';
-- b
SELECT DISTINCT * FROM ADVISOR join instructor on I_ID = ID WHERE name='Einstein'  --学生导师的查询

select distinct * --使用using不能限定
from (student join takes using(ID)) --学生课程
join (instructor join teaches using(ID)) --老师教的课程
using(course_id, sec_id, semester, year) 
where instructor.name = 'Einstein'

SELECT DISTINCT * from takes join (instructor join teaches using(ID)) using(COURSE_ID) WHERE instructor.name = 'Einstein'
-- c
SELECT max(salary) AS max_salary FROM instructor
-- d
SELECT name FROM instructor WHERE salary = (
SELECT max(salary) AS max_salary FROM instructor)
-- e
SELECT course_id,count(course_id) AS c_course FROM takes WHERE semester='Fall' GROUP BY course_id

select course_id, sec_id, count(ID)
from section natural join takes
where semester = 'Fall'
and year = 2009
group by course_id, sec_id

select course_id, sec_id,
(select count(ID)
from takes
where takes.year = section.year
and takes.semester = section.semester
and takes.course_id = section.course_id
and takes.sec_id = section.sec_id)
from section
where semester = 'Fall'
and year = 2009
--f
SELECT max(c_course) AS max_students FROM (
SELECT course_id,count(course_id) AS c_course FROM takes WHERE semester='Fall' and YEAR = 2009 GROUP BY course_id) fall_course

select max(enrollment)
from (select count(ID) as enrollment
from section natural join takes
where semester = 'Fall'
and year = 2009
group by course_id, sec_id)

--g
SELECT course_id FROM (
SELECT course_id,count(course_id) AS c_course FROM takes WHERE semester='Fall' GROUP BY course_id) fall_course WHERE c_course IN (
SELECT max(c_course) AS max_students FROM (
SELECT course_id,count(course_id) AS c_course FROM takes WHERE semester='Fall' GROUP BY course_id) fall_course)

with sec_enrollment as ( --子查询部分（subquery factoring）
select course_id, sec_id, count(ID) as enrollment
from section natural join takes
where semester ='Fall'
and year = 2009
group by course_id, sec_id)
select course_id, sec_id
from sec_enrollment
where enrollment = (select max(enrollment) from sec_enrollment)

-- #3.3
-- a
update INSTRUCTOR set SALARY = SALARY * 1.1 WHERE DEPT_NAME = 'Comp. Sci.'

-- b
DELETE from COURSE where COURSE_ID not in (SELECT COURSE_ID from SECTION)

-- c

INSERT INTO INSTRUCTOR SELECT ID,NAME,DEPT_NAME,10000 as SALARY FROM STUDENT WHERE TOT_CRED > 100 --插入失败。salary要求大于29000

-- #3.6
SELECT * FROM DEPARTMENT WHERE LOWER(DEPT_NAME) LIKE '%sci%'

-- #3.11
-- a
SELECT DISTINCT NAME FROM STUDENT WHERE DEPT_NAME = 'Comp. Sci.'

select DISTINCT name
from student natural join takes natural join course --多此一举
where DEPT_NAME = 'Comp. Sci.'

-- b
SELECT DISTINCT ID,NAME FROM STUDENT JOIN TAKES using(ID) WHERE ID not in (SELECT ID FROM TAKES WHERE YEAR = 2009 and SEMESTER = 'Spring')

select id, name
from student 
MINUS -- Oracle ; 等同于 sql server 的 EXCEPT
select id, name from student natural join takes
where YEAR = 2009 and SEMESTER = 'Spring'

-- c
SELECT DEPT_NAME, MAX(SALARY) FROM INSTRUCTOR GROUP BY DEPT_NAME

-- d
WITH dept_salary as (SELECT DEPT_NAME, MAX(SALARY) as max_salary FROM INSTRUCTOR GROUP BY DEPT_NAME)
SELECT min(max_salary) FROM dept_salary

-- #3.12
-- a
INSERT into COURSE(COURSE_ID,TITLE,CREDITS) VALUES('CS-001','Weekly Seminar' ,0)

-- b
INSERT INTO SECTION(COURSE_ID,SEC_ID,SEMESTER,YEAR) VALUES('CS-001',1,'Fall',2009)

-- c
INSERT into TAKES(ID,COURSE_ID,SEC_ID,SEMESTER,YEAR) SELECT ID,'CS-001',1,'Fall',2009 FROM STUDENT WHERE DEPT_NAME = 'Comp. Sci.'

-- d
DELETE from TAKES WHERE ID = (SELECT ID FROM STUDENT WHERE NAME = 'Chavez') and COURSE_ID = 'CS-001'

-- e
DELETE FROM COURSE WHERE COURSE_ID = 'CS-001' --授课信息section和takes也会删除该课程段

-- true 要先删除takes和section 因为takes 外键引用 section ,而 section 外键引用course
delete from takes
where course_id = 'CS-001'
delete from section
where course_id = 'CS-001'
delete from course
where course_id = 'CS-001'
-- f
DELETE FROM TAKES WHERE COURSE_ID in (SELECT COURSE_ID FROM COURSE WHERE lower(TITLE) LIKE '%database%')

-- #3.13
create table person
	(driver_id  VARCHAR(50),
	 name       VARCHAR(50),
	 address    VARCHAR(50),
	 primary key (driver_id)
	);

create table car
	(license  VARCHAR(50),
	 model    VARCHAR(50),
	 year     INTEGER,
	 primary key (license)
	 );
	 
create table accident
	(report_number  INTEGER,
	 "date"           DATE,
	 location       VARCHAR(50),
	 primary key (report_number));
	 
create table owns
	(driver_id varchar(50),
	 license   varchar(50),
	 primary key (driver_id,license),
	 foreign key (driver_id) references person,
	 foreign key (license) references car
	 );
	 
create table participated
	(REPORT_NUMBER integer,
	 license       varchar(50),
	 driver_id     varchar(50),
	 damage_amount integer,
	 primary key (report_number,license),
	 foreign key (license) references car,
	 foreign key (report_number) references accident
   );
	 
-- 3.18

-- “null”表示未知值。
-- 当值不存在时，也使用“null”。

-- 3.19 <>all 等价于 not in


-- 3.22 不使用unique 重写
-- SELECT TITLE FROM COURSE where unique (SELECT title from COURSE) --缺失表达式
SELECT TITLE FROM COURSE where 1 <= (SELECT COUNT(title) from COURSE GROUP BY TITLE)
-- 参考答案
SELECT TITLE FROM COURSE where(
(select count(title)
from course) =
(select count (distinct title)
from course))

-- 3.23
select course_id, semester, year, sec_id, avg(TOT_CRED)
from takes natural join student
where year = 2009
group by course_id, semester, year, sec_id
having count(ID) >= 2;

select course_id, semester, year, sec_id, avg(TOT_CRED)
from (takes natural join student) NATURAL join SECTION
where year = 2009
group by course_id, semester, year, sec_id
having count(ID) >= 2;
--  take和section的公共属性构成了take的外键，并引用section。因此，每个元组最多只能匹配一个元组元组，并且任何组中都不会有任何额外的元组。 此外，这些属性不能采用空值，因为它们是take的主键的一部分。 因此，from子句中的join部分不会导致任何组中的元组丢失。 所以结果没有变化。

-- 3.24 改写前
with dept_total (dept_name, value) as
(select dept_name, sum(salary)
from instructor
group by dept_name),
dept_total_avg(value) as
(select avg(value)
from dept_total)
select dept_name
from dept_total, dept_total_avg
where dept_total.value >= dept_total_avg.value;

-- 改写后
select dept_name
from (select dept_name, sum(salary) as value from instructor group by dept_name) dept_total , (select avg(value) as value from (select dept_name, sum(salary) as value from instructor group by dept_name)) dept_total_avg
where dept_total.value >= dept_total_avg.value;

```
